<html>
	<head>
		<title>Simple three.js app</title>
		<style>
			body { margin: 0; }
			/*canvas { width: 100%; height: 100% }*/
		</style>
    <script src="three.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="LUT.js"></script>
	</head>
	<body>
		<canvas id="cvs" width="352" height="288"></canvas>
		<script>
      
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
      
      var scene = new THREE.Scene();
      var nimbusData= new Int16Array(352*288*2  );
      
      //var material = new THREE.PointsMaterial( { color: 'rgb( 255, 255, 255 )' } );
      var material = new THREE.PointsMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: THREE.VertexColors
				} );
      var geometry = new THREE.BufferGeometry();
      var positions = new Int16Array( 101376 * 3 );
      var lutColors = new Float32Array( 101376 * 3 );

      var lut = new THREE.Lut( 'rainbow', 512);
      var MAX_COLOR = 20000;
      var MIN_COLOR = 0;
      lut.setMax(MAX_COLOR);
      lut.setMin(MIN_COLOR);     
      for( var i = 0; i < 101376; i++ ) {
	  colorVal = Math.floor((Math.random() * 1000) + 1);
	  color = lut.getColor(colorVal);
          lutColors[ 3 * i ] = 1;//color.r;
          lutColors[ 3 * i + 1 ] = 0;//color.g;
	  lutColors[ 3 * i + 2 ] = 0;//color.b;
      }
      geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
      geometry.addAttribute( 'color', new THREE.BufferAttribute( lutColors , 3 ) );
      geometry.setDrawRange( 0, 101376 );
      
      var points = new THREE.Points( geometry, material );
      scene.add( points );
      
      var cubesInit = false;

      var rot_angle = 0;
var canvas = document.getElementById("cvs");
var ctx = canvas.getContext('2d');


      var ws=new WebSocket("ws://"+location.host+":8080/stream");
      ws.binaryType = 'arraybuffer';

      ws.onmessage=function(evt){
	      var data = evt.data;
	      offset = 2*288*352;
	      length = 288*352;
              var startTime = new Date().getTime();
	      dist_arr = new Uint16Array(evt.data, offset, length);
	      offset += 2*288*352;
	      conf = new Uint8Array(evt.data, offset, length);
              offset += 288*352;
	      x_arr = new Int16Array(evt.data, offset, length);
              offset += 288*352*2;
	      y_arr = new Int16Array(evt.data, offset, length);
	      offset += 288*352*2;
	      z_arr = new Int16Array(evt.data, offset, length);
	      var delay = (new Date().getTime() - startTime)
              console.log( 'extract data from arr: ' + delay );
              startTime = new Date().getTime();
	      setupScene(x_arr, y_arr, z_arr, dist_arr, conf);
	      delay = (new Date().getTime() - startTime)
              console.log( 'setupScene: ' + delay);
      };


      function setupScene(x_arr, y_arr, z_arr, dist_arr, conf) {
        
        
        var dataSize = x_arr.length;
        
        var positions = points.geometry.attributes.position.array;
        var lutColors = points.geometry.attributes.color.array;
        var posIndex = 0;
        

	rot_angle = rot_angle + 0.1;
	if (rot_angle > 2*3.14)
	{
           rot_angle = 0;
	}

	var x=0.0;
	var y=1.0;
	var x_new = x*Math.cos(rot_angle)-y*Math.sin(rot_angle);
	var y_new = x*Math.sin(rot_angle)+y*Math.cos(rot_angle);
	console.log(rot_angle + "/" + x_new + "/" + y_new);

	
        //camera.up = new THREE.Vector3(0,x_new,y_new*10);
        camera.up = new THREE.Vector3(x_new,y_new,0);
	

        for( var index = 0; index < dataSize; index++ ) 
	{
          
	  var colorVal = dist_arr[index];
	  if (colorVal > MAX_COLOR)
              colorVal = MAX_COLOR;
	  else if (colorVal < MIN_COLOR)
              colorVal = MIN_COLOR;

	  var color = lut.getColor(colorVal);
	  if(conf[index] == 0)
	  {
	      positions[posIndex++] = x_arr[index];
              positions[posIndex++] = y_arr[index];
              positions[posIndex++] = z_arr[index];
	      lutColors[ 3 * index ] = color.r;
  	      lutColors[ 3 * index + 1 ] = color.g;
	      lutColors[ 3 * index + 2 ] = color.b;
	  }
	  else
	  {
	      positions[posIndex++] = 0;
	      positions[posIndex++] = 0;
	      positions[posIndex++] = -30000;
	      lutColors[ 3 * index ] = 0;
  	      lutColors[ 3 * index + 1 ] = 0;
	      lutColors[ 3 * index + 2 ] = 0;

	  }
	  if ( color === undefined ) 
	  {
	      console.log("undefined color");
	  }
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
	controls.update();
        renderer.render( scene, camera );

function GetColour(v,vmin,vmax)
{
   var r = 1.0;
   var g = 1.0;
   var b = 1.0;
   var dv;

   if (v < vmin)
      v = vmin;
   if (v > vmax)
      v = vmax;
   dv = vmax - vmin;

   if (v < (vmin + 0.25 * dv)) {
      r = 0;
      g = 4 * (v - vmin) / dv;
   } else if (v < (vmin + 0.5 * dv)) {
      r = 0;
      b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
   } else if (v < (vmin + 0.75 * dv)) {
      r = 4 * (v - vmin - 0.5 * dv) / dv;
      b = 0;
   } else {
      g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
      b = 0;
   }

   return [r, g, b];
}

	// imageData is Uint8ClampedArray
        var imageData = ctx.getImageData(0, 0, 352,288);
var numPixels=352*288;
// this part seems slow :( 
for(var i = 0; i < numPixels; i++) {
    var col = GetColour(z_arr[i], 0, 10000);
    var r = col[0];
    var g = col[1];
    var b = col[2];
    imageData.data[4*i] = r*255;//(z_arr[i])/255;
    imageData.data[4*i+1] = g*255;//(z_arr[i])/255;
    imageData.data[4*i+2] = b*255;//(z_arr[i])/255;
    imageData.data[4*i+3] = 255;
}

ctx.putImageData(imageData, 0, 0);

      }
      
      function setupCamera() {
        camera = new THREE.PerspectiveCamera( 100, window.innerWidth/window.innerHeight, 0.1, 100000 );
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 30000;
        
        camera.up = new THREE.Vector3(0,-1,1);
        camera.lookAt(new THREE.Vector3(0,0,1));

	controls = new THREE.TrackballControls( camera, renderer.domElement );
	controls.target.set( 0, 0, 0 );
	controls.update();
      }
      
      var animate = function() {
        console.log( 'Starting' );
        startTime = new Date().getTime();
        
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After request animation?: ' + delay );
        
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After updating positions?: ' + delay );
        
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After render data?: ' + delay );
      };
      
      // init
      setupCamera();
      animate();
      
      
		</script>
	</body>
</html>
