<html>
	<head>
		<title>Simple three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
    <script src="three.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="LUT.js"></script>
	</head>
	<body>
		<script>
      
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
      
      var scene = new THREE.Scene();
      var nimbusData= new Int16Array(352*288*2  );
      
      //var material = new THREE.PointsMaterial( { color: 'rgb( 255, 255, 255 )' } );
      var material = new THREE.PointsMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: THREE.VertexColors
				} );
      var geometry = new THREE.BufferGeometry();
      var positions = new Int16Array( 101376 * 3 );
      var lutColors = new Float32Array( 101376 * 3 );

      var lut = new THREE.Lut( 'rainbow', 512);
      var MAX_COLOR = 20000;
      var MIN_COLOR = 0;
      lut.setMax(MAX_COLOR);
      lut.setMin(MIN_COLOR);     
      for( var i = 0; i < 101376; i++ ) {
	  colorVal = Math.floor((Math.random() * 1000) + 1);
	  color = lut.getColor(colorVal);
          lutColors[ 3 * i ] = 1;//color.r;
          lutColors[ 3 * i + 1 ] = 0;//color.g;
	  lutColors[ 3 * i + 2 ] = 0;//color.b;
      }
      geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
      geometry.addAttribute( 'color', new THREE.BufferAttribute( lutColors , 3 ) );
      geometry.setDrawRange( 0, 101376 );
      
      var points = new THREE.Points( geometry, material );
      scene.add( points );
      
      var cubesInit = false;

      var ws=new WebSocket("ws://"+location.host+":8080/stream");
      ws.binaryType = 'arraybuffer';

      ws.onmessage=function(evt){
	      var data = evt.data;
	      offset = 2*288*352;
	      length = 288*352;
              var startTime = new Date().getTime();
	      dist_arr = new Uint16Array(evt.data, offset, length);
	      offset += 2*288*352;
	      conf = new Uint8Array(evt.data, offset, length);
              offset += 288*352;
	      x_arr = new Int16Array(evt.data, offset, length);
              offset += 288*352*2;
	      y_arr = new Int16Array(evt.data, offset, length);
	      offset += 288*352*2;
	      z_arr = new Int16Array(evt.data, offset, length);
	      var delay = (new Date().getTime() - startTime)
              console.log( 'extract data from arr: ' + delay );
              startTime = new Date().getTime();
	      setupScene(x_arr, y_arr, z_arr, dist_arr, conf);
	      delay = (new Date().getTime() - startTime)
              console.log( 'setupScene: ' + delay);
      };


      function setupScene(x_arr, y_arr, z_arr, dist_arr, conf) {
        
        
        var dataSize = x_arr.length;
        
        var positions = points.geometry.attributes.position.array;
        var lutColors = points.geometry.attributes.color.array;
        var posIndex = 0;
        
        for( var index = 0; index < dataSize; index++ ) 
	{
          
	  var colorVal = dist_arr[index];
	  if (colorVal > MAX_COLOR)
              colorVal = MAX_COLOR;
	  else if (colorVal < MIN_COLOR)
              colorVal = MIN_COLOR;

	  var color = lut.getColor(colorVal);
	  if(conf[index] == 0)
	  {
	      positions[posIndex++] = x_arr[index];
              positions[posIndex++] = y_arr[index];
              positions[posIndex++] = z_arr[index];
	      lutColors[ 3 * index ] = color.r;
  	      lutColors[ 3 * index + 1 ] = color.g;
	      lutColors[ 3 * index + 2 ] = color.b;
	  }
	  else
	  {
	      positions[posIndex++] = 0;
	      positions[posIndex++] = 0;
	      positions[posIndex++] = -30000;
	      lutColors[ 3 * index ] = 0;
  	      lutColors[ 3 * index + 1 ] = 0;
	      lutColors[ 3 * index + 2 ] = 0;

	  }
	  if ( color === undefined ) 
	  {
	      console.log("undefined color");
	  }
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
	controls.update();
        renderer.render( scene, camera );

      }
      
      function setupCamera() {
        camera = new THREE.PerspectiveCamera( 100, window.innerWidth/window.innerHeight, 0.1, 100000 );
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 30000;
        
        // camera.up = new THREE.Vector3(0,0,1);
        camera.lookAt(new THREE.Vector3(0,0,1));

	controls = new THREE.TrackballControls( camera, renderer.domElement );
	controls.target.set( 0, 0, 0 );
	controls.update();
      }
      
      var animate = function() {
        console.log( 'Starting' );
        startTime = new Date().getTime();
        
        //requestAnimationFrame(animate);
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After request animation?: ' + delay );
        
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After updating positions?: ' + delay );
        
        
        var delay = (new Date().getTime() - startTime)
        console.log( 'After render data?: ' + delay );
      };
      
      // init
      setupCamera();
      animate();
      
      
		</script>
	</body>
</html>
